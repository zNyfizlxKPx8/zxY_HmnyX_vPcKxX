


































































































-- Protección de scripts por MAC address
local allowedMACs = {
  "200DB001ABD50000", -- Under
  "F8A2D6EE5F970000", -- Power Abuser
  -- Agrega aquí más MACs autorizadas si quieres
}

-- Cambia esta línea manualmente si quieres probar en otra PC
local currentMAC = "200DB001ABD50000"  -- <- Pon aquí la MAC convertida del dispositivo actual

-- Verificar si la MAC está en la lista autorizada
if not table.find(allowedMACs, currentMAC, true) then
  modules.corelib.displayInfoBox("Acceso Denegado", "Tu MAC:\n\n" .. currentMAC .. "\n\nNO esta autorizada para usar estos scripts.", "Protección xOxMacrosxOx")
  CaveBot.setOff()
  TargetBot.setOff()
  return
end

modules.game_textmessage.displayGameMessage("Acceso permitido. Scripts protegidos cargados correctamente.")

-- scripts 

-- HP & POT ~~ SPELLS By Undersky~~
setDefaultTab("Hp")
local label = UI.Label(" H E A L   &   POTION")
label:setColor("#a73ec1") -- Color base
label:setFont("verdana-11px-rounded")

local glowPosition = 1
local glowDirection = 1

macro(50, function()
    local text = " H E A L   &   P O T I O N"
    local numChars = #text
    local glowRange = math.max(1, math.floor(numChars / 10)) 
    local coloredText = {}

    for i = 1, numChars do
        local char = text:sub(i, i)
        local color = "#a73ec1" -- Color base
        if math.abs(i - glowPosition) <= glowRange then
            color = "#dfbae9" -- Color de brillo
        end
        table.insert(coloredText, char)
        table.insert(coloredText, color)
    end

    glowPosition = glowPosition + glowDirection
    if glowPosition > numChars then
        glowPosition = numChars - 1
        glowDirection = -1
    elseif glowPosition < 1 then
        glowPosition = 2
        glowDirection = 1
    end

    label:setColoredText(coloredText)
end)
UI.Separator()
-- HP & POT ~~ SPELLS By Undersky~~
if type(storage.healing1) ~= "table" then
  storage.healing1 = {on=false, title="HP%", text="exura", min=70, max=90}
end
if type(storage.healing2) ~= "table" then
  storage.healing2 = {on=false, title="HP%", text="exura vita", min=0, max=69}
end

-- Crear 2 widgets de curación
for _, healingInfo in ipairs({storage.healing1, storage.healing2}) do
  local healingmacro = macro(400, function()
    local hp = player:getHealthPercent()
    local mana = player:getMana()

    -- Definir costo del hechizo
    local spellText = healingInfo.text:lower()
    local spellCost = ({
      ["exura"] = 20,
      ["exura vita"] = 160,
      ["exura gran"] = 70,
      ["exura san"] = 160,
      ["exana mort"] = 65,
      ["exura gran ico"] = 200,
      ["exura ico"] = 40,
      ["exura gran san"] = 210,
      ["exura sio"] = 140
    })[spellText] or 0

    -- Solo lanzar el hechizo si tienes suficiente mana
    if healingInfo.max >= hp and hp >= healingInfo.min and mana >= spellCost then
      if TargetBot then 
        TargetBot.saySpell(healingInfo.text)
      else
        say(healingInfo.text)
      end
    end
  end)
  healingmacro.setOn(healingInfo.on)

  UI.DualScrollPanel(healingInfo, function(widget, newParams) 
    healingInfo = newParams
    healingmacro.setOn(healingInfo.on)
  end)
end

UI.Separator()

-- POCIONES & RUNAS
local labelpot = UI.Label("Pociones/Runas")
labelpot:setColor("#00FFFF")

if type(storage.hpitem1) ~= "table" then
  storage.hpitem1 = {on=false, title="HP%", item=266, min=51, max=90}
end
if type(storage.hpitem2) ~= "table" then
  storage.hpitem2 = {on=false, title="HP%", item=3160, min=0, max=50}
end
if type(storage.manaitem1) ~= "table" then
  storage.manaitem1 = {on=false, title="MP%", item=238, min=0, max=60}
end
if type(storage.manaitem2) ~= "table" then
  storage.manaitem2 = {on=false, title="MP%", item=3157, min=0, max=50}
end

for i, healingInfo in ipairs({storage.hpitem1, storage.hpitem2, storage.manaitem1, storage.manaitem2}) do
  local healingmacro = macro(600, function()
    local hp = i <= 2 and player:getHealthPercent() or math.min(100, math.floor(100 * (player:getMana() / player:getMaxMana())))
    if healingInfo.max >= hp and hp >= healingInfo.min then
      if TargetBot then 
        TargetBot.useItem(healingInfo.item, healingInfo.subType, player)
      else
        local thing = g_things.getThingType(healingInfo.item)
        local subType = g_game.getClientVersion() >= 860 and 0 or 1
        if thing and thing:isFluidContainer() then
          subType = healingInfo.subType
        end
        g_game.useInventoryItemWith(healingInfo.item, player, subType)
      end
    end
  end)
  healingmacro.setOn(healingInfo.on)

  UI.DualScrollItemPanel(healingInfo, function(widget, newParams) 
    healingInfo = newParams
    healingmacro.setOn(healingInfo.on and healingInfo.item > 100)
  end)
end

if g_game.getClientVersion() < 860 then
  UI.Label("In old tibia potions & runes work only when you have backpack with them opened")
end
UI.Separator()
-- Utamo Vita
local labelutamo = UI.Label("Utamo Vita")
labelutamo:setColor("#00FFFF") -- celeste

UI.TextEdit(storage.manaShield or "utamo vita", function(widget, newText)
  storage.manaShield = newText
end)

local lastManaShield = 0

macro(20, "Mana Shield", function() 
  if not hasManaShield() and lastManaShield + 1000 < now then  -- Si no tienes el hechizo activo y han pasado 500ms
    if TargetBot then 
      TargetBot.saySpell(storage.manaShield) -- Usa TargetBot si está activo
    else
      say(storage.manaShield)
    end
    lastManaShield = now -- Guarda el tiempo del último casteo
  end
end)

-- Haste
local labelhaste = UI.Label("Haste")
labelhaste:setColor("#00FFFF") -- celeste

UI.TextEdit(storage.hasteSpell or "utani gran hur", function(widget, newText)
  storage.hasteSpell = newText
end)

macro(500, "Haste", function() 
  if hasHaste() then return end
  if TargetBot then 
    TargetBot.saySpell(storage.hasteSpell) -- sync spell with targetbot if available
  else
    say(storage.hasteSpell)
  end
end)

-- Tira Haste Cuando No Detecte Monster
local spellHaste = "Utani Gran Hur"
local hasteInPz = true -- Usar haste en PZ.

macro(500, "Haste NO Monsters", function()
    if not hasteInPz and isInPz() then 
        return 
    end

    if hasHaste() then 
        return 
    end

    local function monstersinScreen()
        for _, spec in ipairs(getSpectators()) do
            if spec ~= player and spec:isMonster() then
                return true
            end
        end
        return false
    end

    if not monstersinScreen() then
        say(spellHaste)
    end
end)

-- Antiparalyze
local labelparalyze = UI.Label("Antiparalyze")
labelparalyze:setColor("#00FFFF") -- celeste
UI.TextEdit(storage.antiParalyze or "utani gran hur", function(widget, newText)
  storage.antiParalyze = newText
end)

macro(20, "Anti Paralyze", function() 
  if not isParalyzed() then return end
  if TargetBot then 
    TargetBot.saySpell(storage.antiParalyze) -- sync spell with targetbot if available
  else
    say(storage.antiParalyze)
  end
end)

-- Discord Webhook

--[[
    Discord Webhook Automatico para vBot OTC Tibia
    ==============================================
    
    Proposito: Enviar notificaciones automaticas del estado del personaje al Discord
    Ultima modificacion: 2024-12-19
    Autor: vBot Team
    
    Funciones AUTOMATICAS:
    - Estado periodico (cada 10 minutos)
    - Subida de nivel (deteccion automatica)
    - Muerte (deteccion automatica)
]]

-- Configuracion del webhook
local webhook = "https://discord.com/api/webhooks/1402532878340067369/jZjwXMagpK7Wk7969QoHUUsIJ70gO-qviOATh-n5Eoekdu9bikoAtjQOeJeZ4BgJBDqc"

-- Datos predeterminados del bot
local default_data = {
    username = "vBot Status",
}

-- Configuracion del embed
local embed = {
    color = 10038562, -- Color predeterminado (rojo)
    footer = {
        text = "UnderbotStatus by Underbot Scripts | discord.gg/EUXd8Fsmzk",
    },
}

-- Cache de tiempos para controlar cooldown
local discordTimes = {}

-- Variables para control automatico
local lastLevel = 0
local lastHP = 100
local isDead = false
local levelStartTime = 0 -- Tiempo cuando empezo el nivel actual
local levelHistory = {} -- Historial de tiempos de subida de nivel

-- Callback para resultado HTTP
function onHTTPResult(data, err)
    if err then
        print("Discord Webhook Error: " .. err)
    else
        print("Discord Webhook: Mensaje enviado con exito!")
    end
end

-- Funcion principal para enviar webhook
function sendDiscordWebhook(data)
    local id = data.id
    if id then
        local dTime = discordTimes[id]
        if dTime and os.time() < dTime then 
            return 
        end
        discordTimes[id] = os.time() + (data.delayed and data.delayed or 10)
    end

    local messageWithTime = data.message
    if not messageWithTime:find("Horario:") then
        messageWithTime = messageWithTime .. " | Horario: " .. getCurrentTime()
    end

    local dEmbed = {
        title = "**" .. data.title .. "**",
        color = data.color or embed.color,
        footer = embed.footer,
        fields = {
            {
                name = "Nombre:",
                value = data.name,
            },
            {
                name = "Mensaje",
                value = messageWithTime,
            }
        }
    }

    local dataSend = {
        username = default_data.username,
        embeds = { dEmbed }
    }
    
    HTTP.postJSON(webhook, dataSend, onHTTPResult)
end

-- Funcion para formatear posicion
function formatPosition(pos)
    if not pos then return "Desconocida" end
    return string.format("X: %d, Y: %d, Z: %d", pos.x, pos.y, pos.z)
end

-- Funcion para obtener informacion del servidor
function getServerInfo()
    local worldName = g_game.getWorldName()
    
    if worldName then
        return worldName
    else
        return "Desconocido"
    end
end

-- Funcion para obtener stamina actual
function getStaminaInfo()
    local stamina = g_game.getLocalPlayer():getStamina()
    if stamina then
        -- Convertir minutos a horas y minutos
        local hours = math.floor(stamina / 60)
        local minutes = stamina % 60
        
        if hours == 0 then
            return string.format("%dm", minutes)
        else
            return string.format("%dh %dm", hours, minutes)
        end
    else
        return "N/A"
    end
end

-- Funcion para formatear tiempo legible
function formatTime(seconds)
    if seconds < 60 then
        return string.format("%ds", seconds)
    elseif seconds < 3600 then
        local minutes = math.floor(seconds / 60)
        local secs = seconds % 60
        return string.format("%dm %ds", minutes, secs)
    else
        local hours = math.floor(seconds / 3600)
        local minutes = math.floor((seconds % 3600) / 60)
        return string.format("%dh %dm", hours, minutes)
    end
end

-- Funcion para calcular tiempo promedio de subida de nivel
function calculateAverageLevelTime()
    if #levelHistory == 0 then return 0 end
    
    local totalTime = 0
    for _, entry in ipairs(levelHistory) do
        totalTime = totalTime + entry.time
    end
    
    return math.floor(totalTime / #levelHistory)
end

-- Funcion para obtener horario actual formateado
function getCurrentTime()
    local time = os.date("*t")
    return string.format("%02d:%02d:%02d", time.hour, time.min, time.sec)
end

-- MACRO 1: Estado periodico automatico (cada 10 minutos)
macro(600000, function() -- Ejecuta cada 10 minutos
    local player = g_game.getLocalPlayer()
    if not player then return end
    
    -- Estado de CaveBot
    local cavebotStatus = "Inactivo"
    if CaveBot.isOn() then
        cavebotStatus = "Activo"
    end
    
    -- Estado de TargetBot
    local targetStatus = "Inactivo"
    if TargetBot.isOn() then
        targetStatus = "Activo"
    end
    
    -- Estado de zona PZ (zona de proteccion)
    local pzStatus = "PZ"
    if isInPz() then
        pzStatus = "En PZ"
    end
    
    -- Calcular tiempo promedio de subida de nivel
    local avgLevelTime = "N/A"
    if #levelHistory > 0 then
        local avgSeconds = calculateAverageLevelTime()
        avgLevelTime = formatTime(avgSeconds)
    end
    
    local data = {
        title = 'Estado del Personaje',
        name = player:getName(),
        message = string.format('Informacion General:\nNivel: %d\nServidor: %s\nPosicion: %s\nResistencia: %s\n\nEstado de Bots:\nCaveBot: %s\nTargetBot: %s\nPZ: %s\n\nEstadisticas:\nTiempo promedio nivel: %s', 
            player:getLevel(),
            getServerInfo(),
            formatPosition(player:getPosition()),
            getStaminaInfo(),
            cavebotStatus,
            targetStatus,
            pzStatus,
            avgLevelTime),
        id = "status",
        delayed = 600, -- 10 minutos
        color = 0x0099FF -- Azul
    }
    sendDiscordWebhook(data)
end)

-- MACRO 2: Deteccion automatica de subida de nivel
macro(1000, function() -- Ejecuta cada 1 segundo
    local player = g_game.getLocalPlayer()
    if not player then return end
    
    local currentLevel = player:getLevel()
    
    if currentLevel > lastLevel and lastLevel > 0 then
        local currentTime = os.time()
        local timeToLevel = currentTime - levelStartTime
        local timeToLevelFormatted = formatTime(timeToLevel)
        
        local nextLevelEstimate = ""
        if #levelHistory > 0 then
            local avgTime = calculateAverageLevelTime()
            nextLevelEstimate = string.format(" | Proximo nivel estimado: %s", formatTime(avgTime))
        end
        
        table.insert(levelHistory, {level = lastLevel, time = timeToLevel})
        if #levelHistory > 5 then
            table.remove(levelHistory, 1)
        end
        
        local data = {
            title = 'Subida de Nivel!',
            name = player:getName(),
            message = string.format('Felicidades! Llegaste al nivel %d!\n\nDetalles:\nServidor: %s\nTiempo para nivel: %s%s', 
                currentLevel, getServerInfo(), timeToLevelFormatted, nextLevelEstimate),
            id = "level_up",
            delayed = 0,
            color = 0x00FF00 -- Verde
        }
        sendDiscordWebhook(data)
        
        levelStartTime = currentTime
    end
    
    lastLevel = currentLevel
end)

-- Variables para capturar informacion de muerte
local recentAttackers = {} -- Lista de atacantes recientes del server log
local serverLogBuffer = {} -- Buffer de ultimas 10 lineas del server log
local isDead = false

-- Callback para capturar danos del server log
onTextMessage(function(mode, text)
    if mode == 22 then -- Server log
        print("DEBUG Server Log: " .. text)
        
        table.insert(serverLogBuffer, text)
        if #serverLogBuffer > 10 then
            table.remove(serverLogBuffer, 1)
        end
        
        local damage, attackerName = text:match("You lose (%d+) hitpoints due to an attack by ([^.]+)")
        if attackerName then
            print("DEBUG: Capturado ataque - Dano: " .. damage .. " | Atacante: " .. attackerName)
            
            table.insert(recentAttackers, {name = attackerName, time = os.time(), damage = tonumber(damage)})
            
            local currentTime = os.time()
            for i = #recentAttackers, 1, -1 do
                if currentTime - recentAttackers[i].time > 5 then
                    table.remove(recentAttackers, i)
                end
            end
            
            print("DEBUG: Total atacantes recientes: " .. #recentAttackers)
        end
    end
end)

-- MACRO 3: Deteccion automatica de muerte
macro(1000, function() -- Ejecuta cada 1 segundo
    local player = g_game.getLocalPlayer()
    if not player then return end
    
    local currentHP = player:getHealthPercent()
    
    if currentHP == 0 and not isDead then
        isDead = true
        
        local deathCause = "Desconocida"
        
        print("DEBUG: Muerte detectada! Total atacantes recientes: " .. #recentAttackers)
        print("DEBUG: Ultimas 10 lineas del server log:")
        for i, line in ipairs(serverLogBuffer) do
            print("DEBUG: " .. i .. ": " .. line)
        end
        
        local lastDamages = {}
        for i = #serverLogBuffer, 1, -1 do
            local line = serverLogBuffer[i]
            local damage, attackerName = line:match("You lose (%d+) hitpoints due to an attack by ([^.]+)")
            if attackerName then
                table.insert(lastDamages, {damage = tonumber(damage), attacker = attackerName})
            end
        end
        
        if #lastDamages > 0 then
            local lastDamage = lastDamages[1]
            deathCause = lastDamage.attacker
            
            if #lastDamages > 1 then
                deathCause = lastDamage.attacker .. " (ultimo dano)"
            end
        else
            local nearbyCreatures = {}
            for _, creature in ipairs(getSpectators()) do
                if (creature:isMonster() or creature:isPlayer()) and creature ~= player and getDistanceBetween(player:getPosition(), creature:getPosition()) <= 3 then
                    table.insert(nearbyCreatures, creature:getName())
                end
            end
            
            if #nearbyCreatures == 1 then
                deathCause = nearbyCreatures[1]
            elseif #nearbyCreatures > 1 then
                deathCause = nearbyCreatures[1] .. " (+" .. (#nearbyCreatures - 1) .. " otros)"
            end
        end
        
        local data = {
            title = 'Personaje Muerto!',
            name = player:getName(),
            message = string.format('Personaje muerto!\n\nInformacion:\nNivel: %d\nServidor: %s\nPosicion: %s\nMuerto por: %s', 
                player:getLevel(), 
                getServerInfo(),
                formatPosition(player:getPosition()),
                deathCause),
            id = "death",
            delayed = 300, -- 5 minutos
            color = 0xFF0000 -- Rojo
        }
        sendDiscordWebhook(data)
    end
    
    if currentHP > 0 and isDead then
        isDead = false
        recentAttackers = {}
    end
    
    lastHP = currentHP
end)

-- Variable para controlar inicializacion
local systemInitialized = false

-- MACRO 4: Inicializacion (primer estado)
macro(5000, function() -- Ejecuta despues de 5 segundos
    local player = g_game.getLocalPlayer()
    if not player then return end
    
    if systemInitialized then return end
    
    lastLevel = player:getLevel()
    levelStartTime = os.time()
    
    local data = {
        title = 'Sistema Iniciado',
        name = player:getName(),
        message = string.format('Sistema UnderbotStatus iniciado!\n\nInformacion:\nNivel: %d\nServidor: %s\nSistema automatico activo!', 
            player:getLevel(), getServerInfo()),
        id = "init",
        delayed = 0,
        color = 0x0099FF -- Azul
    }
    sendDiscordWebhook(data)
    
    systemInitialized = true
end)

-- Interfaz de usuario (solo informativa)
UI.Separator()
UI.Label("UnderbotStatus Discord ACTIVADO")
UI.Separator()

print("UnderbotStatus Discord: Sistema activo!")
